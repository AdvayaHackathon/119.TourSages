<!DOCTYPE html>
<html>

<head>
    <title>Tourism Route Planner</title>
    <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Google Sans', sans-serif;
        }

        body {
            display: flex;
            height: 100vh;
        }

        #controls {
            width: 30.8%;
            height: 100vh;
            padding: 24px;
            background: #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        #map {
            flex: 1;
            height: 100vh;
        }

        h3 {
            color: #1a73e8;
            font-size: 24px;
            margin-bottom: 5px;
        }

        #pr {
            margin-bottom: 20px;
            font-size: 0.9em;
        }

        .input-group {
            margin-bottom: 16px;
        }

        input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #dadce0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #1a73e8;
            box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
        }

        .btn {
            background: #1a73e8;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            margin: 8px 0;
        }

        .btn:hover {
            background: #1557b0;
        }

        .btn.secondary {
            background: #fff;
            color: #1a73e8;
            border: 1px solid #1a73e8;
        }

        .btn.danger {
            background: #dc3545;
        }

        .waypoint {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .place-card {
            background: white;
            margin: 16px 0;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.2s;
        }

        .place-card:hover {
            transform: translateY(-2px);
        }

        .place-card img {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        .place-info {
            padding: 16px;
        }

        .place-name {
            font-weight: 500;
            color: #202124;
            margin-bottom: 4px;
        }

        .place-address {
            font-size: 13px;
            color: #5f6368;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .loading.active {
            display: block;
        }

        .interests-container {
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .interests-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .interest-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .interest-item:hover {
            background: #e8f0fe;
        }

        .place-card {
            position: relative;
            background: white;
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s;
        }

        .place-details {
            padding: 16px;
        }

        .suggested-time {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        .photo-gallery {
            display: flex;
            gap: 8px;
            padding: 8px;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
        }

        .place-photo {
            width: 120px;
            height: 120px;
            border-radius: 8px;
            object-fit: cover;
            scroll-snap-align: start;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .place-photo:hover {
            transform: scale(1.05);
        }

        .plan-container {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .plan-list {
            margin-top: 10px;
        }

        .plan-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: white;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .btn.small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            animation: slideIn 0.3s ease-out, fadeOut 0.3s ease-out 1.7s;
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .toast.success {
            background: #34a853;
        }

        .toast.error {
            background: #ea4335;
        }

        .toast.info {
            background: #4285f4;
        }

        .toast.warning {
            background: #fbbc05;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }

            to {
                opacity: 0;
                transform: translateX(100%);
            }
        }
    </style>
</head>

<body>
    <div id="controls">
        <h3>TourSages Oracle</h3>
        <p id="pr">A wise travel seer that knows the best paths before you even ask.</p>
        <div class="input-group">
            <input id="source" placeholder="Enter Starting Point" type="text">
        </div>
        <div class="input-group">
            <input id="destination" placeholder="Enter Destination" type="text">
        </div>
        <div class="interests-container">
            <h4>Select Your Interests</h4>
            <div class="interests-grid">
                <label class="interest-item">
                    <input type="checkbox" value="historical" name="interests">
                    üèõÔ∏è Historical
                </label>
                <label class="interest-item">
                    <input type="checkbox" value="nature" name="interests">
                    üå≥ Nature
                </label>
                <label class="interest-item">
                    <input type="checkbox" value="food" name="interests">
                    üçΩÔ∏è Food
                </label>
                <label class="interest-item">
                    <input type="checkbox" value="culture" name="interests">
                    üé≠ Culture
                </label>
                <label class="interest-item">
                    <input type="checkbox" value="shopping" name="interests">
                    üõçÔ∏è Shopping
                </label>
            </div>
        </div>

        <button class="btn primary" onclick="getGeminiRecommendations()">
            ü§ñ Get AI Recommendations
        </button>
        <button class="btn secondary" onclick="useCurrentLocation()">
            üìç Use Current Location
        </button>
        <div id="waypoints" class="waypoints-container"></div>
        <button class="btn" onclick="addWaypoint()">
            ‚ûï Add Stop
        </button>
        <button class="btn" onclick="calculateRoute()">
            üó∫Ô∏è Create Route
        </button>
        <div id="planDisplay"></div>
        <div id="placeCards"></div>
    </div>
    <div id="map"></div>
    <div class="loading" id="loading">
        Optimizing your route...
    </div>

    <script>
        let map, directionsService, directionsRenderer, currentPos;
        let waypointInputs = [];
        let nearbyPlaces = [];
        let currentPlan = {
            source: '',
            destination: '',
            waypoints: [],
            recommendations: []
        };

        async function useCurrentLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(pos => {
                    currentPos = {
                        lat: pos.coords.latitude,
                        lng: pos.coords.longitude
                    };

                    // Reverse geocode to get address
                    const geocoder = new google.maps.Geocoder();
                    geocoder.geocode({
                        location: currentPos
                    }, (results, status) => {
                        if (status === 'OK') {
                            document.getElementById("source").value = results[0].formatted_address;
                        }
                    });
                }, () => {
                    showToast("Error: The Geolocation service failed.", "error");
                });
            } else {
                showToast("Your browser doesn't support geolocation.", "error");
            }
        }

        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 6,
                center: { lat: 12.9716, lng: 77.5946 },
                mapTypeControl: false,
                fullscreenControl: false,
                streetViewControl: false
            });

            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                suppressMarkers: false,
                polylineOptions: {
                    strokeColor: "#1a73e8",
                    strokeWeight: 5,
                    strokeOpacity: 0.8
                },
                markerOptions: {
                    animation: google.maps.Animation.DROP
                }
            });

            // Initialize autocomplete
            ['source', 'destination'].forEach(id => {
                new google.maps.places.Autocomplete(
                    document.getElementById(id),
                    { types: ['geocode'] }
                );
            });
        }

        function addWaypoint() {
            const waypointDiv = document.createElement("div");
            waypointDiv.className = "waypoint";

            const input = document.createElement("input");
            input.type = "text";
            input.placeholder = "Enter stop location";
            const autocomplete = new google.maps.places.Autocomplete(input, { types: ['geocode'] });

            const addBtn = document.createElement("button");
            addBtn.className = "btn secondary";
            addBtn.innerHTML = "Add";
            addBtn.onclick = async () => {
                const place = input.value;
                if (place) {
                    await addPlaceToPlan(place);
                    input.value = ''; // Clear input after adding
                }
            };

            const removeBtn = document.createElement("button");
            removeBtn.className = "btn danger";
            removeBtn.innerHTML = "‚úñ";
            removeBtn.onclick = () => waypointDiv.remove();

            waypointDiv.appendChild(input);
            waypointDiv.appendChild(addBtn);
            waypointDiv.appendChild(removeBtn);
            document.getElementById("waypoints").appendChild(waypointDiv);
        }

        async function calculateRouteDistance(source, destination) {
            try {
                const geocoder = new google.maps.Geocoder();
                const [sourceResult, destResult] = await Promise.all([
                    new Promise((resolve) => geocoder.geocode({ address: source }, resolve)),
                    new Promise((resolve) => geocoder.geocode({ address: destination }, resolve))
                ]);

                if (!sourceResult[0] || !destResult[0]) {
                    throw new Error('Could not get coordinates for source or destination');
                }

                const sourceLocation = sourceResult[0].geometry.location;
                const destLocation = destResult[0].geometry.location;

                // Calculate direct distance between source and destination
                return google.maps.geometry.spherical.computeDistanceBetween(
                    sourceLocation,
                    destLocation
                );
            } catch (error) {
                console.error('Error calculating route distance:', error);
                return null;
            }
        }

        async function filterPlacesNearRoute(source, destination, places) {
            try {
                // Get coordinates for source and destination
                const geocoder = new google.maps.Geocoder();
                const [sourceResult, destResult] = await Promise.all([
                    new Promise((resolve) => geocoder.geocode({ address: source }, resolve)),
                    new Promise((resolve) => geocoder.geocode({ address: destination }, resolve))
                ]);

                if (!sourceResult[0] || !destResult[0]) {
                    console.error('Could not get coordinates for source or destination');
                    return places;
                }

                const sourceLocation = sourceResult[0].geometry.location;
                const destLocation = destResult[0].geometry.location;

                // Calculate direct route distance
                const directDistance = google.maps.geometry.spherical.computeDistanceBetween(
                    sourceLocation,
                    destLocation
                );

                // Create a path between source and destination
                const path = new google.maps.Polyline({
                    path: [sourceLocation, destLocation],
                    geodesic: true
                });

                // Filter places that are within 5km of the route and don't exceed 50km from direct route
                const nearbyPlaces = places.filter(place => {
                    try {
                        const placeLocation = new google.maps.LatLng(
                            parseFloat(place.latitude),
                            parseFloat(place.longitude)
                        );

                        // Calculate distance from the route
                        const distanceFromRoute = google.maps.geometry.spherical.computeDistanceBetween(
                            placeLocation,
                            path.getPath().getAt(0)
                        );

                        // Calculate total detour distance if we include this place
                        const distanceToPlace = google.maps.geometry.spherical.computeDistanceBetween(
                            sourceLocation,
                            placeLocation
                        ) + google.maps.geometry.spherical.computeDistanceBetween(
                            placeLocation,
                            destLocation
                        );

                        // Check if the place is within 5km of the route AND
                        // the total detour doesn't exceed 50km more than the direct route
                        return distanceFromRoute <= 5000 && (distanceToPlace - directDistance) <= 50000;
                    } catch (error) {
                        console.error('Error calculating distance for place:', place, error);
                        return false;
                    }
                });

                return nearbyPlaces;
            } catch (error) {
                console.error('Error filtering places near route:', error);
                return places;
            }
        }

        async function fetchNearbyPlaces(source, destination) {
            try {
                const response = await fetch('http://localhost:9999/api/route-places', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        source: source,
                        destination: destination
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch nearby places');
                }

                const data = await response.json();

                // Ensure data is an array
                if (!Array.isArray(data)) {
                    console.error('API response is not an array:', data);
                    return [];
                }

                // Filter places that are near the route
                const filteredPlaces = await filterPlacesNearRoute(source, destination, data);
                nearbyPlaces = filteredPlaces;
                return filteredPlaces;
            } catch (error) {
                console.error('Error fetching nearby places:', error);
                return [];
            }
        }

        async function getOptimizedOrderGemini(source, destination, waypoints) {
            // Calculate direct route distance
            const directDistance = await calculateRouteDistance(source, destination);
            if (!directDistance) {
                console.error('Could not calculate route distance');
                return waypoints;
            }

            // Fetch and filter nearby places
            const nearbyPlaces = await fetchNearbyPlaces(source, destination);

            // Ensure nearbyPlaces is an array
            if (!Array.isArray(nearbyPlaces)) {
                console.error('Nearby places is not an array:', nearbyPlaces);
                return waypoints;
            }

            const prompt = `
                I need to optimize a route from ${source} to ${destination} 
                visiting these stops: ${waypoints.join(", ")}.
                
                Consider these places that are near the route:
                ${nearbyPlaces.map(place => `
                    - ${place.place} (${place.region || 'Unknown Region'}): ${place.description}
                    Category: ${getCategoryName(place.category)}
                `).join('\n')}
                
                Important Constraints:
                1. The total route distance must not exceed the direct route by more than 50km
                2. All stops must be within 5km of the main route
                3. Places should be visited in a logical order
                
                Consider factors like:
                1. Logical progression based on locations
                2. Minimizing travel time
                3. Including relevant places that are on the way
                4. Not making detours from the main route
                5. Grouping places by category (1: Food, 3: Temple, etc.)

                Return only a numbered list of stops in the optimal order, including relevant places.
                The route must not exceed the direct distance by more than 50km.
            `;

            try {
                const response = await fetch(
                    "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent",
                    {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer AIzaSyAoObRWOz586pwfOvjXY1ZUx3hm9R6DURg`
                        },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }]
                        })
                    }
                );

                const data = await response.json();
                const optimizedOrder = data.candidates[0].content.parts[0].text
                    .split('\n')
                    .filter(line => line.trim())
                    .map(line => line.replace(/^\d+\.\s*/, '').trim());

                return optimizedOrder;
            } catch (error) {
                console.error('Optimization error:', error);
                return waypoints;
            }
        }

        function getCategoryName(category) {
            switch (category) {
                case 1: return 'Food';
                case 2: return 'Hotel';
                case 3: return 'Temple';
                case 4: return 'Historical';
                default: return 'Point of Interest';
            }
        }

        async function getGeminiRouteRecommendation(source, destination, interests) {
            const prompt = `
                You are a travel expert. Create a tourist route from ${source} to ${destination}.
                Consider these interests: ${interests.join(", ")}.
                
                For each stop, provide exactly 5 stops in this format:
                
                Stop: [Exact name of the tourist attraction or location]
                Description: [2-3 sentences about what makes this place special]
                Time: [Suggested duration in hours or days]
                
                Example:
                Stop: Taj Mahal
                Description: A stunning white marble mausoleum built by Mughal emperor Shah Jahan in memory of his wife. Known for its intricate architecture and beautiful gardens.
                Time: 2-3 hours
                
                Make sure to:
                1. Use exact, real place names
                2. Keep descriptions concise but informative
                3. Provide realistic time estimates
                4. Focus on popular tourist attractions
                5. Choose places that are actually on the route
                
                If you cannot generate specific recommendations, provide an optimal route plan between ${source} and ${destination} with these stops:
                - Major cities or towns along the way
                - Important landmarks or attractions
                - Rest stops or points of interest
                - Any significant cultural or historical sites
            `;

            try {
                const response = await fetch(
                    "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=AIzaSyAoObRWOz586pwfOvjXY1ZUx3hm9R6DURg",
                    {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: {
                                temperature: 0.7,
                                topK: 40,
                                topP: 0.95,
                                maxOutputTokens: 1024,
                            }
                        })
                    }
                );

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('API Error:', errorData);
                    throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                    throw new Error('Invalid response format from Gemini API');
                }

                const responseText = data.candidates[0].content.parts[0].text;
                console.log('API Response:', responseText);

                let recommendations = parseGeminiResponse(responseText);

                // If no valid recommendations, try to extract stops from the response
                if (!recommendations || recommendations.length === 0) {
                    // Try to extract stops from the response text
                    const lines = responseText.split('\n');
                    const extractedStops = [];
                    let currentStop = {};

                    for (const line of lines) {
                        const trimmedLine = line.trim();
                        if (trimmedLine.toLowerCase().includes('stop') || trimmedLine.match(/^\d+\./)) {
                            if (Object.keys(currentStop).length > 0) {
                                extractedStops.push(currentStop);
                            }
                            currentStop = {
                                name: trimmedLine.replace(/^(stop:|^\d+\.)\s*/i, '').trim(),
                                description: 'Major point along the route',
                                time: '1-2 hours'
                            };
                        }
                    }

                    if (Object.keys(currentStop).length > 0) {
                        extractedStops.push(currentStop);
                    }

                    if (extractedStops.length > 0) {
                        recommendations = extractedStops;
                    } else {
                        // If still no stops, create a basic route with major cities
                        const geocoder = new google.maps.Geocoder();
                        const [sourceResult, destResult] = await Promise.all([
                            new Promise((resolve) => geocoder.geocode({ address: source }, resolve)),
                            new Promise((resolve) => geocoder.geocode({ address: destination }, resolve))
                        ]);

                        if (sourceResult[0] && destResult[0]) {
                            const sourceCity = sourceResult[0].address_components.find(
                                comp => comp.types.includes('locality')
                            )?.long_name || source;

                            const destCity = destResult[0].address_components.find(
                                comp => comp.types.includes('locality')
                            )?.long_name || destination;

                            recommendations = [
                                {
                                    name: sourceCity,
                                    description: 'Starting point of your journey',
                                    time: 'Starting point'
                                },
                                {
                                    name: destCity,
                                    description: 'Destination of your journey',
                                    time: 'Destination'
                                }
                            ];
                        }
                    }
                }

                // Validate recommendations
                const validRecommendations = recommendations.filter(rec =>
                    rec.name &&
                    rec.name.length > 0 &&
                    rec.description &&
                    rec.description.length > 0
                );

                if (validRecommendations.length === 0) {
                    // If all else fails, return a simple route
                    return [
                        {
                            name: source,
                            description: 'Starting point of your journey',
                            time: 'Starting point'
                        },
                        {
                            name: destination,
                            description: 'Destination of your journey',
                            time: 'Destination'
                        }
                    ];
                }

                return validRecommendations;
            } catch (error) {
                console.error('Gemini API error:', error);
                // Return a basic route on error
                return [
                    {
                        name: source,
                        description: 'Starting point of your journey',
                        time: 'Starting point'
                    },
                    {
                        name: destination,
                        description: 'Destination of your journey',
                        time: 'Destination'
                    }
                ];
            }
        }

        function parseGeminiResponse(responseText) {
            const recommendations = [];
            const lines = responseText.split('\n');
            let currentRecommendation = {};

            for (const line of lines) {
                const trimmedLine = line.trim();

                if (trimmedLine.startsWith('Stop:')) {
                    if (Object.keys(currentRecommendation).length > 0) {
                        recommendations.push(currentRecommendation);
                    }
                    currentRecommendation = {
                        name: trimmedLine.replace('Stop:', '').trim(),
                        description: '',
                        time: ''
                    };
                } else if (trimmedLine.startsWith('Description:')) {
                    currentRecommendation.description = trimmedLine.replace('Description:', '').trim();
                } else if (trimmedLine.startsWith('Time:')) {
                    currentRecommendation.time = trimmedLine.replace('Time:', '').trim();
                }
            }

            if (Object.keys(currentRecommendation).length > 0) {
                recommendations.push(currentRecommendation);
            }

            // Additional validation
            return recommendations.filter(rec =>
                rec.name &&
                rec.name.length > 0 &&
                rec.description &&
                rec.description.length > 0
            );
        }

        async function getGeminiRecommendations() {
            const source = document.getElementById("source").value;
            const destination = document.getElementById("destination").value;
            const interests = Array.from(document.querySelectorAll('input[name="interests"]:checked'))
                .map(checkbox => checkbox.value);

            if (!source || !destination) {
                showToast("Please enter both source and destination!", "warning");
                return;
            }

            if (interests.length === 0) {
                showToast("Please select at least one interest!", "warning");
                return;
            }

            document.getElementById('loading').classList.add('active');
            document.getElementById('loading').textContent = "Getting recommendations and calculating route...";

            try {
                // First fetch nearby places
                const nearbyPlaces = await fetchNearbyPlaces(source, destination);

                // Then get recommendations
                const recommendations = await getGeminiRouteRecommendation(source, destination, interests);
                if (recommendations) {
                    // Update current plan
                    currentPlan = {
                        source,
                        destination,
                        waypoints: recommendations.map(rec => rec.name),
                        recommendations
                    };

                    displayRecommendations(recommendations);
                    updateRoute();
                    updatePlanDisplay();
                }
            } catch (error) {
                console.error('Error getting recommendations:', error);
                showToast(`Failed to get recommendations: ${error.message}`, "error");
            } finally {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loading').textContent = "Optimizing your route...";
            }
        }

        function displayRecommendations(recommendations) {
            const container = document.getElementById("placeCards");
            container.innerHTML = "";

            if (!Array.isArray(recommendations)) {
                console.error('Recommendations is not an array:', recommendations);
                return;
            }

            recommendations.forEach((rec, index) => {
                if (!rec || !rec.name || !rec.description) return;

                // Find the full place details from nearbyPlaces
                const placeDetails = Array.isArray(nearbyPlaces)
                    ? nearbyPlaces.find(p => p && p.place === rec.name)
                    : null;

                const card = document.createElement("div");
                card.className = "place-card";
                card.innerHTML = `
                    <div class="place-details">
                        <h3 class="place-name">${index + 1}. ${rec.name}</h3>
                        <p class="place-description">${placeDetails ? placeDetails.description : rec.description}</p>
                        ${placeDetails ? `
                            <div class="place-info">
                                <span class="region">üìç ${placeDetails.region || 'Unknown Region'}</span>
                                <span class="category">${getCategoryIcon(placeDetails.category)}</span>
                            </div>
                        ` : ''}
                        <div class="suggested-time">‚è±Ô∏è ${rec.time || 'Time not specified'}</div>
                        <button class="btn secondary small" onclick="addPlaceToPlan('${rec.name.replace(/'/g, "\\'")}')">Add to Plan</button>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function getCategoryIcon(category) {
            switch (category) {
                case 1: return 'üçΩÔ∏è Food';
                case 2: return 'üè® Hotel';
                case 3: return 'üõï Temple';
                case 4: return 'üèõÔ∏è Historical';
                default: return 'üìç Point of Interest';
            }
        }

        function updateRoute() {
            if (!currentPlan.source || !currentPlan.destination) {
                console.log('Source or destination missing');
                return;
            }

            const waypointsList = currentPlan.waypoints.map(location => ({
                location,
                stopover: true
            }));

            console.log('Calculating route with:', {
                origin: currentPlan.source,
                destination: currentPlan.destination,
                waypoints: waypointsList
            });

            const request = {
                origin: currentPlan.source,
                destination: currentPlan.destination,
                waypoints: waypointsList,
                optimizeWaypoints: true,
                travelMode: google.maps.TravelMode.DRIVING
            };

            // First try to calculate the full route
            directionsService.route(request, (result, status) => {
                if (status === "OK") {
                    showToast("Route calculated successfully!", "success");
                    directionsRenderer.setDirections(result);

                    // Fit the map to show the entire route
                    const bounds = new google.maps.LatLngBounds();
                    result.routes[0].legs.forEach(leg => {
                        bounds.extend(leg.start_location);
                        bounds.extend(leg.end_location);
                    });
                    map.fitBounds(bounds);

                    showPlaceCards([currentPlan.source, ...currentPlan.waypoints, currentPlan.destination]);
                } else {
                    console.warn("Full route calculation failed, trying basic route:", status);

                    // If full route fails, try basic route without waypoints
                    const basicRequest = {
                        origin: currentPlan.source,
                        destination: currentPlan.destination,
                        travelMode: google.maps.TravelMode.DRIVING
                    };

                    directionsService.route(basicRequest, (basicResult, basicStatus) => {
                        if (basicStatus === "OK") {
                            showToast("Route calculated successfully!", "success");
                            directionsRenderer.setDirections(basicResult);

                            // Fit the map to show the basic route
                            const bounds = new google.maps.LatLngBounds();
                            basicResult.routes[0].legs.forEach(leg => {
                                bounds.extend(leg.start_location);
                                bounds.extend(leg.end_location);
                            });
                            map.fitBounds(bounds);

                            // Show a warning to the user
                            showToast("Showing basic route. Some stops might be unavailable.", "info");

                            // Show place cards for the basic route
                            showPlaceCards([currentPlan.source, currentPlan.destination]);
                        } else {
                            console.error("Basic route calculation also failed:", basicStatus);
                            showToast("Could not calculate the route. Please check the locations and try again.", "error");
                        }
                    });
                }
            });
        }

        async function addPlaceToPlan(place) {
            if (!place) return;

            if (!currentPlan.waypoints.includes(place)) {
                try {
                    // Get place details
                    const placeDetails = await getPlaceDetails(place);
                    if (placeDetails) {
                        currentPlan.waypoints.push(place);
                        updateRoute(); // This will now handle both full and basic routes
                        updatePlanDisplay();
                        updatePlaceCards();
                    }
                } catch (error) {
                    console.error('Error adding place to plan:', error);
                    // Still add the place even if details can't be fetched
                    currentPlan.waypoints.push(place);
                    updateRoute();
                    updatePlanDisplay();
                    updatePlaceCards();
                }
            }
        }

        async function getPlaceDetails(place) {
            try {
                const service = new google.maps.places.PlacesService(map);
                return new Promise((resolve, reject) => {
                    service.findPlaceFromQuery({
                        query: place,
                        fields: ['name', 'photos', 'place_id', 'formatted_address']
                    }, (results, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && results[0]) {
                            resolve(results[0]);
                        } else {
                            reject(new Error('Place not found'));
                        }
                    });
                });
            } catch (error) {
                console.error('Error getting place details:', error);
                return null;
            }
        }

        function updatePlaceCards() {
            const container = document.getElementById("placeCards");
            container.innerHTML = "";

            // Display all places in the current plan
            [currentPlan.source, ...currentPlan.waypoints, currentPlan.destination].forEach(async (place, index) => {
                if (!place) return;

                const card = document.createElement("div");
                card.className = "place-card";

                try {
                    const details = await getPlaceDetails(place);
                    if (details) {
                        card.innerHTML = `
                            <div class="place-details">
                                <h3 class="place-name">${index + 1}. ${details.name}</h3>
                                <p class="place-address">${details.formatted_address}</p>
                                ${details.photos ? `
                                    <div class="photo-gallery">
                                        <img src="${details.photos[0].getUrl({ maxWidth: 400, maxHeight: 400 })}" 
                                             alt="${details.name}" 
                                             class="place-photo">
                                    </div>
                                ` : ''}
                                <button class="btn danger small" onclick="removePlaceFromPlan('${place.replace(/'/g, "\\'")}')">Remove from Plan</button>
                            </div>
                        `;
                    } else {
                        card.innerHTML = `
                            <div class="place-details">
                                <h3 class="place-name">${index + 1}. ${place}</h3>
                                <button class="btn danger small" onclick="removePlaceFromPlan('${place.replace(/'/g, "\\'")}')">Remove from Plan</button>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('Error creating place card:', error);
                    card.innerHTML = `
                        <div class="place-details">
                            <h3 class="place-name">${index + 1}. ${place}</h3>
                            <button class="btn danger small" onclick="removePlaceFromPlan('${place.replace(/'/g, "\\'")}')">Remove from Plan</button>
                        </div>
                    `;
                }

                container.appendChild(card);
            });
        }

        function removePlaceFromPlan(place) {
            const index = currentPlan.waypoints.indexOf(place);
            if (index > -1) {
                currentPlan.waypoints.splice(index, 1);
                updateRoute();
                updatePlanDisplay();
                updatePlaceCards();
            }
        }

        function updatePlanDisplay() {
            const planContainer = document.getElementById("planDisplay");
            if (!planContainer) {
                const newContainer = document.createElement("div");
                newContainer.id = "planDisplay";
                newContainer.className = "plan-container";
                document.getElementById("controls").appendChild(newContainer);
            }

            const planHtml = `
                <h4>Current Plan</h4>
                <div class="plan-list">
                    <div class="plan-item">
                        <span>Start: ${currentPlan.source || 'Not set'}</span>
                    </div>
                    ${currentPlan.waypoints.map((place, index) => `
                        <div class="plan-item">
                            <span>${index + 1}. ${place}</span>
                            <button class="btn danger small" onclick="removePlaceFromPlan('${place.replace(/'/g, "\\'")}')">‚úñ</button>
                        </div>
                    `).join('')}
                    <div class="plan-item">
                        <span>End: ${currentPlan.destination || 'Not set'}</span>
                    </div>
                </div>
            `;

            document.getElementById("planDisplay").innerHTML = planHtml;
        }

        async function calculateRoute() {
            document.getElementById('loading').classList.add('active');

            const source = document.getElementById("source").value;
            const destination = document.getElementById("destination").value;

            if (!source || !destination) {
                showToast("Please enter both source and destination!", "warning");
                document.getElementById('loading').classList.remove('active');
                return;
            }

            // Update current plan with new source and destination
            currentPlan.source = source;
            currentPlan.destination = destination;

            try {
                // First get the coordinates for source and destination
                const geocoder = new google.maps.Geocoder();
                const [sourceResult, destResult] = await Promise.all([
                    new Promise((resolve) => geocoder.geocode({ address: source }, resolve)),
                    new Promise((resolve) => geocoder.geocode({ address: destination }, resolve))
                ]);

                if (sourceResult[0] && destResult[0]) {
                    // Center the map between source and destination
                    const bounds = new google.maps.LatLngBounds();
                    bounds.extend(sourceResult[0].geometry.location);
                    bounds.extend(destResult[0].geometry.location);
                    map.fitBounds(bounds);

                    // Update the route
                    updateRoute();
                    updatePlanDisplay();
                    updatePlaceCards();
                } else {
                    // If geocoding fails, still try to show a basic route
                    console.warn("Geocoding failed, attempting basic route");
                    updateRoute();
                }
            } catch (error) {
                console.error('Error in route calculation:', error);
                // Even if there's an error, try to show a basic route
                updateRoute();
            } finally {
                document.getElementById('loading').classList.remove('active');
            }
        }

        // Replace the existing showPlaceCards function
        async function showPlaceCards(places) {
            const container = document.getElementById("placeCards");
            container.innerHTML = "";

            for (const place of places) {
                const card = document.createElement("div");
                card.className = "place-card";

                try {
                    const placeDetails = await getPlacePhotos(place);

                    const photosHtml = placeDetails.photos
                        .map(photo => `
                    <img 
                        src="${photo.url}" 
                        alt="${place}" 
                        class="place-photo"
                        onclick="showFullImage('${photo.url}')"
                    >
                `).join('');

                    const reviewsHtml = placeDetails.reviews
                        .map(review => `
                    <div class="review">
                        <div class="stars">${'‚≠ê'.repeat(review.rating)}</div>
                        <p>${review.text.slice(0, 100)}...</p>
                    </div>
                `).join('');

                    card.innerHTML = `
                <div class="photo-gallery">
                    ${photosHtml}
                </div>
                <div class="place-details">
                    <h3 class="place-name">${place}</h3>
                    <span class="open-status ${placeDetails.openNow ? 'open' : 'closed'}">
                        ${placeDetails.openNow ? 'üü¢ Open Now' : 'üî¥ Closed'}
                    </span>
                    <div class="reviews-container">
                        ${reviewsHtml}
                    </div>
                </div>
            `;

                    container.appendChild(card);
                } catch (error) {
                    console.error('Error creating place card:', error);
                }
            }
        }
        // Replace the existing getPlacePhoto function
        async function getPlacePhotos(place) {
            try {
                const service = new google.maps.places.PlacesService(map);

                return new Promise((resolve, reject) => {
                    service.findPlaceFromQuery({
                        query: place,
                        fields: ['photos', 'place_id']
                    }, async (results, status) => {
                        if (status === google.maps.places.PlacesServiceStatus.OK && results[0]) {
                            const placeId = results[0].place_id;

                            service.getDetails({
                                placeId: placeId,
                                fields: ['photos', 'reviews', 'opening_hours']
                            }, (place, detailsStatus) => {
                                if (detailsStatus === google.maps.places.PlacesServiceStatus.OK) {
                                    const photos = place.photos?.slice(0, 5).map(photo => ({
                                        url: photo.getUrl({ maxWidth: 400, maxHeight: 400 }),
                                        attribution: photo.html_attributions
                                    })) || [];

                                    resolve({
                                        photos,
                                        placeId,
                                        openNow: place.opening_hours?.isOpen() || false,
                                        reviews: place.reviews?.slice(0, 3) || []
                                    });
                                } else {
                                    reject(new Error('Failed to get place details'));
                                }
                            });
                        } else {
                            reject(new Error('Place not found'));
                        }
                    });
                });
            } catch (error) {
                console.error('Error fetching place photos:', error);
                return {
                    photos: [{ url: "https://via.placeholder.com/400x300?text=No+Image" }],
                    placeId: null,
                    openNow: false,
                    reviews: []
                };
            }
        }
    </script>
    <script>
        // Add this right after your existing script tag starts

        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            // Add appropriate icon based on type
            let icon = '';
            switch (type) {
                case 'success':
                    icon = '‚úÖ';
                    break;
                case 'error':
                    icon = '‚ùå';
                    break;
                case 'warning':
                    icon = '‚ö†Ô∏è';
                    break;
                case 'info':
                default:
                    icon = '‚ÑπÔ∏è';
                    break;
            }

            toast.innerHTML = `
        <span>${icon}</span>
        <span>${message}</span>
    `;

            container.appendChild(toast);

            // Remove the toast after animation
            setTimeout(() => {
                toast.addEventListener('animationend', () => {
                    toast.remove();
                    container.remove();
                });
            }, 2000);
        }
    </script>
    <script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDGLM_J5yX62bYgvQiHaDLRlyKRwbNe7RQ&libraries=places&callback=initMap">
        </script>
</body>
<div class="toast-container" id="toastContainer"></div>

</html>